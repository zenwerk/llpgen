// Code generated by llpgen. DO NOT EDIT.
package calc

import "core:container/queue"
import "core:fmt"

// ========================================================================
// このパーサーを使用するには、以下の型と関数を別ファイルで定義してください:
//
//   Node :: struct { ... }       // AST ノード型
//   node_free(n: ^Node)                  // ノードの再帰的解放
//   on_parse_event(p: ^Parser, event: Parse_Event, tk: ^Token, top: ^Parse_State)
//                                // パースイベントハンドラ
//
// トークン型は _token.odin に自動生成されます。
// ========================================================================

// パーサーの状態
Parse_State_Kind :: enum {
	// 基本状態
	Start,
	End,
	Error,
	// -- expr --
	Expr,
	Expr_Op,
	// -- term --
	Term,
	Term_Op,
	// -- factor --
	Factor,
	Factor_Await_Left_Paren,
	Factor_Await_Right_Paren,
	Factor_Await_Right_Paren_2,
	// -- args --
	Args,
	Args_Op,
}

// パースイベント種別
Parse_Event :: enum {
	None,
	// -- expr --
	Expr_Op,
	// -- term --
	Term_Op,
	// -- factor --
	Factor_Number,
	Factor_Ident,
	Factor_Left_Paren,
	Factor_Minus,
	Factor_Await_Left_Paren,
	Factor_Await_Right_Paren,
	Factor_Await_Right_Paren_2,
	// -- args --
	Args_Op,
}

// パースループ制御アクション
Parse_Loop_Action :: enum {
	Break,
	Continue,
}

// パース結果
Parse_Result :: enum {
	Parse_End,
	Push_More,
}

// パーサー状態
Parse_State :: struct {
	state:     Parse_State_Kind,
	node:      ^^Node,    // 現在のノードへのポインタ
	saved:     ^Node,     // 保存用ノード
	op:        string,    // 演算子 (必要に応じて)
	user_data: rawptr,    // ユーザー定義データ
}

// パーサー
Parser :: struct {
	state_stack: queue.Queue(Parse_State),
	root:        ^Node,
	error_msg:   string,
	nerr:        int,
}

// パーサーの初期化
parser_new :: proc() -> ^Parser {
	p := new(Parser)
	queue.init(&p.state_stack, capacity = 16)
	p.root = nil
	p.error_msg = ""
	p.nerr = 0
	parser_begin(p, .Start, &p.root)
	return p
}

// パーサーの破棄
parser_destroy :: proc(p: ^Parser) {
	if p == nil {
		return
	}
	queue.destroy(&p.state_stack)
	if p.root != nil {
		node_free(p.root)
	}
	free(p)
}

// パーサーのリセット
parser_reset :: proc(p: ^Parser) {
	queue.clear(&p.state_stack)
	if p.root != nil {
		node_free(p.root)
	}
	p.root = nil
	p.error_msg = ""
	p.nerr = 0
	parser_begin(p, .Start, &p.root)
}

// 新しい状態をスタックにプッシュ
parser_begin :: proc(p: ^Parser, state: Parse_State_Kind, node: ^^Node) {
	queue.push_front(&p.state_stack, Parse_State{state = state, node = node})
}

// 現在の状態をスタックからポップ
parser_end :: proc(p: ^Parser) {
	if queue.len(p.state_stack) > 0 {
		queue.pop_front(&p.state_stack)
	}
}

// 現在の状態を取得
parser_get_state :: proc(p: ^Parser) -> ^Parse_State {
	if queue.len(p.state_stack) <= 0 {
		return nil
	}
	return queue.front_ptr(&p.state_stack)
}

// 現在の状態を更新
parser_set_state :: proc(p: ^Parser, state: Parse_State_Kind, node: ^^Node = nil) {
	if queue.len(p.state_stack) <= 0 {
		return
	}
	top := parser_get_state(p)
	if top == nil {
		return
	}
	top.state = state
	if node != nil {
		top.node = node
	}
}

// エラー状態に遷移
parser_error :: proc(p: ^Parser, msg: string) {
	p.error_msg = msg
	p.nerr += 1
	if p.root != nil {
		node_free(p.root)
	}
	p.root = nil
	queue.clear(&p.state_stack)
	parser_begin(p, .Error, &p.root)
}

// トークンをプッシュしてパース
parser_push_token :: proc(p: ^Parser, token: Token) -> Parse_Result {
	tk := token
	action: Parse_Loop_Action
	max_iterations := 1000

	for i := 0; i < max_iterations; i += 1 {
		top := parser_get_state(p)
		if top == nil {
			break
		}
		pstate := top.state

		if tk.consumed {
			break
		}

		if tk.type == .Error && pstate != .Error {
			parser_error(p, fmt.tprintf("Lexer error: %%s", tk.lexeme))
			break
		}

		// 状態に応じたパース関数を呼び出す
		#partial switch pstate {
		case .Start, .End, .Error:
			action = parse_start(p, &tk)
		case .Expr, .Expr_Op:
			action = parse_expr(p, &tk)
		case .Term, .Term_Op:
			action = parse_term(p, &tk)
		case .Factor, .Factor_Await_Left_Paren, .Factor_Await_Right_Paren, .Factor_Await_Right_Paren_2:
			action = parse_factor(p, &tk)
		case .Args, .Args_Op:
			action = parse_args(p, &tk)
		case:
			fmt.eprintfln("Parse: Unknown state %v", top.state)
			break
		}

		if action == .Break {
			break
		}

		if i >= max_iterations - 1 {
			parser_error(p, "max iterations exceeded in parser_push_token")
		}
	}

	top := parser_get_state(p)
	if top != nil && (top.state == .End || top.state == .Error) {
		return .Parse_End
	}
	return .Push_More
}

// 開始状態のパース
parse_start :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Start:
		if tk.type == .Eof {
			parser_set_state(p, .End)
			return .Break
		}
		parser_set_state(p, .End)
		parser_begin(p, .Expr, top.node)
		return .Continue
	case .End:
		return .Break
	case .Error:
		tk.consumed = true
	}
	return .Break
}

// expr 規則のパース (演算子ループ: term (op expr)*)
parse_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Expr:
		parser_set_state(p, .Expr_Op)
		parser_begin(p, .Term, top.node)
		return .Continue
	case .Expr_Op:
		if tk.type == .Plus || tk.type == .Minus {
			on_parse_event(p, .Expr_Op, tk, top)
			top.op = tk.lexeme
			tk.consumed = true
			parser_begin(p, .Term, top.node)
			return .Continue
		} else {
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// term 規則のパース (演算子ループ: factor (op term)*)
parse_term :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Term:
		parser_set_state(p, .Term_Op)
		parser_begin(p, .Factor, top.node)
		return .Continue
	case .Term_Op:
		if tk.type == .Asterisk || tk.type == .Slash {
			on_parse_event(p, .Term_Op, tk, top)
			top.op = tk.lexeme
			tk.consumed = true
			parser_begin(p, .Factor, top.node)
			return .Continue
		} else {
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// factor 規則のパース
parse_factor :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Factor:
		if tk.type == .Number {
			on_parse_event(p, .Factor_Number, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Ident {
			on_parse_event(p, .Factor_Ident, tk, top)
			tk.consumed = true
			parser_set_state(p, .Factor_Await_Left_Paren)
			return .Continue
		} else if tk.type == .Left_Paren {
			on_parse_event(p, .Factor_Left_Paren, tk, top)
			tk.consumed = true
			parser_set_state(p, .Factor_Await_Right_Paren_2)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else if tk.type == .Minus {
			on_parse_event(p, .Factor_Minus, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Factor, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in factor: %v", tk.type))
			return .Break
		}
	case .Factor_Await_Left_Paren:
		if consumed(tk, .Left_Paren) {
			on_parse_event(p, .Factor_Await_Left_Paren, tk, top)
			parser_set_state(p, .Factor_Await_Right_Paren)
			parser_begin(p, .Args, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Left_Paren, got %v", tk.type))
		}
	case .Factor_Await_Right_Paren:
		if consumed(tk, .Right_Paren) {
			on_parse_event(p, .Factor_Await_Right_Paren, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Right_Paren, got %v", tk.type))
		}
	case .Factor_Await_Right_Paren_2:
		if consumed(tk, .Right_Paren) {
			on_parse_event(p, .Factor_Await_Right_Paren_2, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Right_Paren, got %v", tk.type))
		}
	}
	return .Break
}

// args 規則のパース (演算子ループ: expr (op args)*)
parse_args :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Args:
		if tk.type == .Ident || tk.type == .Left_Paren || tk.type == .Minus || tk.type == .Number {
			parser_set_state(p, .Args_Op)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else {
			parser_set_state(p, .Args_Op)
			return .Continue
		}
	case .Args_Op:
		if tk.type == .Comma {
			on_parse_event(p, .Args_Op, tk, top)
			top.op = tk.lexeme
			tk.consumed = true
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else {
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}


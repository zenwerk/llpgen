// Code generated by llpgen. DO NOT EDIT.
package streem

import "core:container/queue"
import "core:fmt"

// ========================================================================
// このパーサーを使用するには、以下の型と関数を別ファイルで定義してください:
//
//   Node :: struct { ... }       // AST ノード型
//   node_free(n: ^Node)                  // ノードの再帰的解放
//   on_parse_event(p: ^Parser, event: Parse_Event, tk: ^Token, top: ^Parse_State)
//                                // パースイベントハンドラ
//
// トークン型は _token.odin に自動生成されます。
// ========================================================================

// パーサーの状態
Parse_State_Kind :: enum {
	// 基本状態
	Start,
	End,
	Error,
	// -- program --
	Program,
	// -- topstmt_list_opt --
	Topstmt_List_Opt,
	// -- topstmt_rest --
	Topstmt_Rest,
	// -- topstmt --
	Topstmt,
	Topstmt_Await_Ident,
	Topstmt_Await_Lbrace,
	Topstmt_Await_Rbrace,
	Topstmt_Await_Ident_2,
	Topstmt_Await_Lbrace_2,
	Topstmt_Await_Rbrace_2,
	Topstmt_Await_Ident_3,
	Topstmt_Await_Lparen,
	Topstmt_Await_Rparen,
	// -- method_body --
	Method_Body,
	Method_Body_Await_Rbrace,
	// -- stmts --
	Stmts,
	// -- stmt_list_opt --
	Stmt_List_Opt,
	// -- stmt_rest --
	Stmt_Rest,
	// -- stmt --
	Stmt,
	// -- stmt_suffix --
	Stmt_Suffix,
	Stmt_Suffix_Await_Ident,
	// -- def_body --
	Def_Body,
	Def_Body_Await_Rparen,
	// -- expr --
	Expr,
	// -- lambda_expr --
	Lambda_Expr,
	// -- pipe_expr --
	Pipe_Expr,
	Pipe_Expr_Op,
	// -- amper_expr --
	Amper_Expr,
	Amper_Expr_Op,
	// -- or_expr --
	Or_Expr,
	Or_Expr_Op,
	// -- and_expr --
	And_Expr,
	And_Expr_Op,
	// -- eq_expr --
	Eq_Expr,
	Eq_Expr_Op,
	// -- cmp_expr --
	Cmp_Expr,
	Cmp_Expr_Op,
	// -- add_expr --
	Add_Expr,
	Add_Expr_Op,
	// -- mul_expr --
	Mul_Expr,
	Mul_Expr_Op,
	// -- unary_expr --
	Unary_Expr,
	// -- postfix_expr --
	Postfix_Expr,
	// -- postfix_chain --
	Postfix_Chain,
	// -- postfix_access --
	Postfix_Access,
	Postfix_Access_Await_Rparen,
	// -- postfix_call_args --
	Postfix_Call_Args,
	Postfix_Call_Args_Await_Rparen,
	// -- primary --
	Primary,
	Primary_Await_Ident,
	Primary_Await_Lbracket,
	Primary_Await_Rbracket,
	// -- ident_or_call --
	Ident_Or_Call,
	// -- ident_suffix --
	Ident_Suffix,
	Ident_Suffix_Await_Rbrace,
	Ident_Suffix_Await_Rparen,
	// -- paren_expr --
	Paren_Expr,
	// -- paren_content --
	Paren_Content,
	Paren_Content_Await_Rparen,
	// -- paren_suffix --
	Paren_Suffix,
	Paren_Suffix_Await_Rbrace,
	// -- bracket_expr --
	Bracket_Expr,
	// -- bracket_content --
	Bracket_Content,
	Bracket_Content_Await_Rbracket,
	// -- block --
	Block,
	Block_Await_Rbrace,
	// -- block_content --
	Block_Content,
	// -- block_after_ident --
	Block_After_Ident,
	Block_After_Ident_Await_Ident,
	Block_After_Ident_Await_Op_Lambda,
	// -- case_body_rest --
	Case_Body_Rest,
	// -- case_body_cont --
	Case_Body_Cont,
	Case_Body_Cont_Await_Op_Lambda,
	// -- condition --
	Condition,
	Condition_Await_Rparen,
	// -- opt_else --
	Opt_Else,
	// -- opt_args --
	Opt_Args,
	// -- arg --
	Arg,
	// -- arg_rest --
	Arg_Rest,
	// -- opt_f_args --
	Opt_F_Args,
	// -- f_args_rest --
	F_Args_Rest,
	F_Args_Rest_Await_Ident,
	// -- fname --
	Fname,
	// -- cparam --
	Cparam,
	Cparam_Await_Op_Lambda,
	Cparam_Await_Op_Lambda_2,
	Cparam_Await_Kw_If,
	Cparam_Await_Op_Lambda_3,
	// -- pattern --
	Pattern,
	// -- pary_or_pstruct --
	Pary_Or_Pstruct,
	// -- pary_rest --
	Pary_Rest,
	// -- pstruct_rest --
	Pstruct_Rest,
	Pstruct_Rest_Await_Label,
	// -- pattern_splat_opt --
	Pattern_Splat_Opt,
	Pattern_Splat_Opt_Await_Op_Mult,
	// -- splat_tail --
	Splat_Tail,
	// -- pterm --
	Pterm,
	// -- pterm_suffix --
	Pterm_Suffix,
	Pterm_Suffix_Await_Ident,
	// -- pterm_bracket_content --
	Pterm_Bracket_Content,
	Pterm_Bracket_Content_Await_Ident,
	Pterm_Bracket_Content_Await_Rbracket,
	// -- pterm_bracket_at --
	Pterm_Bracket_At,
	Pterm_Bracket_At_Await_Rbracket,
	// -- opt_terms --
	Opt_Terms,
	// -- terms --
	Terms,
	// -- terms_rest --
	Terms_Rest,
	// -- term --
	Term,
	// -- opt_block --
	Opt_Block,
}

// パースイベント種別
Parse_Event :: enum {
	None,
	// -- topstmt --
	Topstmt_Kw_Namespace,
	Topstmt_Kw_Class,
	Topstmt_Kw_Import,
	Topstmt_Kw_Method,
	Topstmt_Await_Ident,
	Topstmt_Await_Lbrace,
	Topstmt_Await_Rbrace,
	Topstmt_Await_Ident_2,
	Topstmt_Await_Lbrace_2,
	Topstmt_Await_Rbrace_2,
	Topstmt_Await_Ident_3,
	Topstmt_Await_Lparen,
	Topstmt_Await_Rparen,
	// -- method_body --
	Method_Body_Lbrace,
	Method_Body_Eq,
	Method_Body_Await_Rbrace,
	// -- stmt --
	Stmt_Kw_Def,
	Stmt_Kw_Skip,
	Stmt_Kw_Emit,
	Stmt_Kw_Return,
	// -- stmt_suffix --
	Stmt_Suffix_Eq,
	Stmt_Suffix_Op_Rasgn,
	Stmt_Suffix_Await_Ident,
	// -- def_body --
	Def_Body_Lparen,
	Def_Body_Eq,
	Def_Body_Await_Rparen,
	// -- expr --
	Expr_Kw_If,
	// -- pipe_expr --
	Pipe_Expr_Op,
	// -- amper_expr --
	Amper_Expr_Op,
	// -- or_expr --
	Or_Expr_Op,
	// -- and_expr --
	And_Expr_Op,
	// -- eq_expr --
	Eq_Expr_Op,
	// -- cmp_expr --
	Cmp_Expr_Op,
	// -- add_expr --
	Add_Expr_Op,
	// -- mul_expr --
	Mul_Expr_Op,
	// -- unary_expr --
	Unary_Expr_Op_Plus,
	Unary_Expr_Op_Minus,
	Unary_Expr_Op_Not,
	Unary_Expr_Op_Tilde,
	// -- postfix_chain --
	Postfix_Chain_Dot,
	// -- postfix_access --
	Postfix_Access_Lparen,
	Postfix_Access_Await_Rparen,
	// -- postfix_call_args --
	Postfix_Call_Args_Lparen,
	Postfix_Call_Args_Await_Rparen,
	// -- primary --
	Primary_Lit_Number,
	Primary_Lit_String,
	Primary_Lit_Symbol,
	Primary_Lit_Time,
	Primary_Kw_Nil,
	Primary_Kw_True,
	Primary_Kw_False,
	Primary_Kw_New,
	Primary_Op_Amper,
	Primary_Await_Ident,
	Primary_Await_Lbracket,
	Primary_Await_Rbracket,
	// -- ident_or_call --
	Ident_Or_Call_Ident,
	// -- ident_suffix --
	Ident_Suffix_Lbrace,
	Ident_Suffix_Lparen,
	Ident_Suffix_Await_Rbrace,
	Ident_Suffix_Await_Rparen,
	// -- paren_expr --
	Paren_Expr_Lparen,
	// -- paren_content --
	Paren_Content_Rparen,
	Paren_Content_Await_Rparen,
	// -- paren_suffix --
	Paren_Suffix_Op_Lambda2,
	Paren_Suffix_Op_Lambda3,
	Paren_Suffix_Await_Rbrace,
	// -- bracket_expr --
	Bracket_Expr_Lbracket,
	// -- bracket_content --
	Bracket_Content_Rbracket,
	Bracket_Content_Await_Rbracket,
	// -- block --
	Block_Lbrace,
	Block_Await_Rbrace,
	// -- block_content --
	Block_Content_Op_Lambda,
	Block_Content_Kw_Case,
	Block_Content_Ident,
	// -- block_after_ident --
	Block_After_Ident_Comma,
	Block_After_Ident_Op_Lambda,
	Block_After_Ident_Await_Ident,
	Block_After_Ident_Await_Op_Lambda,
	// -- case_body_cont --
	Case_Body_Cont_Kw_Case,
	Case_Body_Cont_Kw_Else,
	Case_Body_Cont_Await_Op_Lambda,
	// -- condition --
	Condition_Lparen,
	Condition_Await_Rparen,
	// -- opt_else --
	Opt_Else_Kw_Else,
	// -- arg --
	Arg_Label,
	Arg_Op_Mult,
	// -- arg_rest --
	Arg_Rest_Comma,
	// -- opt_f_args --
	Opt_F_Args_Ident,
	// -- f_args_rest --
	F_Args_Rest_Comma,
	F_Args_Rest_Await_Ident,
	// -- fname --
	Fname_Ident,
	Fname_Lit_String,
	// -- cparam --
	Cparam_Op_Lambda,
	Cparam_Kw_If,
	Cparam_Await_Op_Lambda,
	Cparam_Await_Op_Lambda_2,
	Cparam_Await_Kw_If,
	Cparam_Await_Op_Lambda_3,
	// -- pary_or_pstruct --
	Pary_Or_Pstruct_Label,
	// -- pary_rest --
	Pary_Rest_Comma,
	// -- pstruct_rest --
	Pstruct_Rest_Comma,
	Pstruct_Rest_Await_Label,
	// -- pattern_splat_opt --
	Pattern_Splat_Opt_Comma,
	Pattern_Splat_Opt_Await_Op_Mult,
	// -- splat_tail --
	Splat_Tail_Comma,
	// -- pterm --
	Pterm_Ident,
	Pterm_Lit_Number,
	Pterm_Lit_String,
	Pterm_Kw_Nil,
	Pterm_Kw_True,
	Pterm_Kw_False,
	Pterm_Lbracket,
	// -- pterm_suffix --
	Pterm_Suffix_At,
	Pterm_Suffix_Await_Ident,
	// -- pterm_bracket_content --
	Pterm_Bracket_Content_Rbracket,
	Pterm_Bracket_Content_At,
	Pterm_Bracket_Content_Await_Ident,
	Pterm_Bracket_Content_Await_Rbracket,
	// -- pterm_bracket_at --
	Pterm_Bracket_At_Rbracket,
	Pterm_Bracket_At_Await_Rbracket,
	// -- term --
	Term_Semicolon,
	Term_Newline,
}

// パースループ制御アクション
Parse_Loop_Action :: enum {
	Break,
	Continue,
}

// パース結果
Parse_Result :: enum {
	Parse_End,
	Push_More,
}

// パーサー状態
Parse_State :: struct {
	state:     Parse_State_Kind,
	node:      ^^Node,    // 現在のノードへのポインタ
	saved:     ^Node,     // 保存用ノード
	op:        string,    // 演算子 (必要に応じて)
	user_data: rawptr,    // ユーザー定義データ
}

// パーサー
Parser :: struct {
	state_stack: queue.Queue(Parse_State),
	root:        ^Node,
	error_msg:   string,
	nerr:        int,
}

// パーサーの初期化
parser_new :: proc() -> ^Parser {
	p := new(Parser)
	queue.init(&p.state_stack, capacity = 16)
	p.root = nil
	p.error_msg = ""
	p.nerr = 0
	parser_begin(p, .Start, &p.root)
	return p
}

// パーサーの破棄
parser_destroy :: proc(p: ^Parser) {
	if p == nil {
		return
	}
	queue.destroy(&p.state_stack)
	if p.root != nil {
		node_free(p.root)
	}
	free(p)
}

// パーサーのリセット
parser_reset :: proc(p: ^Parser) {
	queue.clear(&p.state_stack)
	if p.root != nil {
		node_free(p.root)
	}
	p.root = nil
	p.error_msg = ""
	p.nerr = 0
	parser_begin(p, .Start, &p.root)
}

// 新しい状態をスタックにプッシュ
parser_begin :: proc(p: ^Parser, state: Parse_State_Kind, node: ^^Node) {
	queue.push_front(&p.state_stack, Parse_State{state = state, node = node})
}

// 現在の状態をスタックからポップ
parser_end :: proc(p: ^Parser) {
	if queue.len(p.state_stack) > 0 {
		queue.pop_front(&p.state_stack)
	}
}

// 現在の状態を取得
parser_get_state :: proc(p: ^Parser) -> ^Parse_State {
	if queue.len(p.state_stack) <= 0 {
		return nil
	}
	return queue.front_ptr(&p.state_stack)
}

// 現在の状態を更新
parser_set_state :: proc(p: ^Parser, state: Parse_State_Kind, node: ^^Node = nil) {
	if queue.len(p.state_stack) <= 0 {
		return
	}
	top := parser_get_state(p)
	if top == nil {
		return
	}
	top.state = state
	if node != nil {
		top.node = node
	}
}

// エラー状態に遷移
parser_error :: proc(p: ^Parser, msg: string) {
	p.error_msg = msg
	p.nerr += 1
	if p.root != nil {
		node_free(p.root)
	}
	p.root = nil
	queue.clear(&p.state_stack)
	parser_begin(p, .Error, &p.root)
}

// トークンをプッシュしてパース
parser_push_token :: proc(p: ^Parser, token: Token) -> Parse_Result {
	tk := token
	action: Parse_Loop_Action
	max_iterations := 1000

	for i := 0; i < max_iterations; i += 1 {
		top := parser_get_state(p)
		if top == nil {
			break
		}
		pstate := top.state

		if tk.consumed {
			break
		}

		if tk.type == .Error && pstate != .Error {
			parser_error(p, fmt.tprintf("Lexer error: %%s", tk.lexeme))
			break
		}

		// 状態に応じたパース関数を呼び出す
		#partial switch pstate {
		case .Start, .End, .Error:
			action = parse_start(p, &tk)
		case .Program:
			action = parse_program(p, &tk)
		case .Topstmt_List_Opt:
			action = parse_topstmt_list_opt(p, &tk)
		case .Topstmt_Rest:
			action = parse_topstmt_rest(p, &tk)
		case .Topstmt, .Topstmt_Await_Ident, .Topstmt_Await_Lbrace, .Topstmt_Await_Rbrace, .Topstmt_Await_Ident_2, .Topstmt_Await_Lbrace_2, .Topstmt_Await_Rbrace_2, .Topstmt_Await_Ident_3, .Topstmt_Await_Lparen, .Topstmt_Await_Rparen:
			action = parse_topstmt(p, &tk)
		case .Method_Body, .Method_Body_Await_Rbrace:
			action = parse_method_body(p, &tk)
		case .Stmts:
			action = parse_stmts(p, &tk)
		case .Stmt_List_Opt:
			action = parse_stmt_list_opt(p, &tk)
		case .Stmt_Rest:
			action = parse_stmt_rest(p, &tk)
		case .Stmt:
			action = parse_stmt(p, &tk)
		case .Stmt_Suffix, .Stmt_Suffix_Await_Ident:
			action = parse_stmt_suffix(p, &tk)
		case .Def_Body, .Def_Body_Await_Rparen:
			action = parse_def_body(p, &tk)
		case .Expr:
			action = parse_expr(p, &tk)
		case .Lambda_Expr:
			action = parse_lambda_expr(p, &tk)
		case .Pipe_Expr, .Pipe_Expr_Op:
			action = parse_pipe_expr(p, &tk)
		case .Amper_Expr, .Amper_Expr_Op:
			action = parse_amper_expr(p, &tk)
		case .Or_Expr, .Or_Expr_Op:
			action = parse_or_expr(p, &tk)
		case .And_Expr, .And_Expr_Op:
			action = parse_and_expr(p, &tk)
		case .Eq_Expr, .Eq_Expr_Op:
			action = parse_eq_expr(p, &tk)
		case .Cmp_Expr, .Cmp_Expr_Op:
			action = parse_cmp_expr(p, &tk)
		case .Add_Expr, .Add_Expr_Op:
			action = parse_add_expr(p, &tk)
		case .Mul_Expr, .Mul_Expr_Op:
			action = parse_mul_expr(p, &tk)
		case .Unary_Expr:
			action = parse_unary_expr(p, &tk)
		case .Postfix_Expr:
			action = parse_postfix_expr(p, &tk)
		case .Postfix_Chain:
			action = parse_postfix_chain(p, &tk)
		case .Postfix_Access, .Postfix_Access_Await_Rparen:
			action = parse_postfix_access(p, &tk)
		case .Postfix_Call_Args, .Postfix_Call_Args_Await_Rparen:
			action = parse_postfix_call_args(p, &tk)
		case .Primary, .Primary_Await_Ident, .Primary_Await_Lbracket, .Primary_Await_Rbracket:
			action = parse_primary(p, &tk)
		case .Ident_Or_Call:
			action = parse_ident_or_call(p, &tk)
		case .Ident_Suffix, .Ident_Suffix_Await_Rbrace, .Ident_Suffix_Await_Rparen:
			action = parse_ident_suffix(p, &tk)
		case .Paren_Expr:
			action = parse_paren_expr(p, &tk)
		case .Paren_Content, .Paren_Content_Await_Rparen:
			action = parse_paren_content(p, &tk)
		case .Paren_Suffix, .Paren_Suffix_Await_Rbrace:
			action = parse_paren_suffix(p, &tk)
		case .Bracket_Expr:
			action = parse_bracket_expr(p, &tk)
		case .Bracket_Content, .Bracket_Content_Await_Rbracket:
			action = parse_bracket_content(p, &tk)
		case .Block, .Block_Await_Rbrace:
			action = parse_block(p, &tk)
		case .Block_Content:
			action = parse_block_content(p, &tk)
		case .Block_After_Ident, .Block_After_Ident_Await_Ident, .Block_After_Ident_Await_Op_Lambda:
			action = parse_block_after_ident(p, &tk)
		case .Case_Body_Rest:
			action = parse_case_body_rest(p, &tk)
		case .Case_Body_Cont, .Case_Body_Cont_Await_Op_Lambda:
			action = parse_case_body_cont(p, &tk)
		case .Condition, .Condition_Await_Rparen:
			action = parse_condition(p, &tk)
		case .Opt_Else:
			action = parse_opt_else(p, &tk)
		case .Opt_Args:
			action = parse_opt_args(p, &tk)
		case .Arg:
			action = parse_arg(p, &tk)
		case .Arg_Rest:
			action = parse_arg_rest(p, &tk)
		case .Opt_F_Args:
			action = parse_opt_f_args(p, &tk)
		case .F_Args_Rest, .F_Args_Rest_Await_Ident:
			action = parse_f_args_rest(p, &tk)
		case .Fname:
			action = parse_fname(p, &tk)
		case .Cparam, .Cparam_Await_Op_Lambda, .Cparam_Await_Op_Lambda_2, .Cparam_Await_Kw_If, .Cparam_Await_Op_Lambda_3:
			action = parse_cparam(p, &tk)
		case .Pattern:
			action = parse_pattern(p, &tk)
		case .Pary_Or_Pstruct:
			action = parse_pary_or_pstruct(p, &tk)
		case .Pary_Rest:
			action = parse_pary_rest(p, &tk)
		case .Pstruct_Rest, .Pstruct_Rest_Await_Label:
			action = parse_pstruct_rest(p, &tk)
		case .Pattern_Splat_Opt, .Pattern_Splat_Opt_Await_Op_Mult:
			action = parse_pattern_splat_opt(p, &tk)
		case .Splat_Tail:
			action = parse_splat_tail(p, &tk)
		case .Pterm:
			action = parse_pterm(p, &tk)
		case .Pterm_Suffix, .Pterm_Suffix_Await_Ident:
			action = parse_pterm_suffix(p, &tk)
		case .Pterm_Bracket_Content, .Pterm_Bracket_Content_Await_Ident, .Pterm_Bracket_Content_Await_Rbracket:
			action = parse_pterm_bracket_content(p, &tk)
		case .Pterm_Bracket_At, .Pterm_Bracket_At_Await_Rbracket:
			action = parse_pterm_bracket_at(p, &tk)
		case .Opt_Terms:
			action = parse_opt_terms(p, &tk)
		case .Terms:
			action = parse_terms(p, &tk)
		case .Terms_Rest:
			action = parse_terms_rest(p, &tk)
		case .Term:
			action = parse_term(p, &tk)
		case .Opt_Block:
			action = parse_opt_block(p, &tk)
		case:
			fmt.eprintfln("Parse: Unknown state %v", top.state)
			break
		}

		if action == .Break {
			break
		}

		if i >= max_iterations - 1 {
			parser_error(p, "max iterations exceeded in parser_push_token")
		}
	}

	top := parser_get_state(p)
	if top != nil && (top.state == .End || top.state == .Error) {
		return .Parse_End
	}
	return .Push_More
}

// 開始状態のパース
parse_start :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Start:
		if tk.type == .Eof {
			parser_set_state(p, .End)
			return .Break
		}
		parser_set_state(p, .End)
		parser_begin(p, .Program, top.node)
		return .Continue
	case .End:
		return .Break
	case .Error:
		// パニックモード: term トークンまでスキップして再開
		if is_term(tk) {
			tk.consumed = true
			parser_set_state(p, .Start)
			return .Continue
		}
		tk.consumed = true
		return .Continue
	}
	return .Break
}

// program 規則のパース
parse_program :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Program:
		parser_end(p)
		parser_begin(p, .Topstmt_List_Opt, top.node)
		parser_begin(p, .Opt_Terms, top.node)
		return .Continue
	}
	return .Break
}

// topstmt_list_opt 規則のパース
parse_topstmt_list_opt :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Topstmt_List_Opt:
		if tk.type == .Ident || tk.type == .Kw_Class || tk.type == .Kw_Def || tk.type == .Kw_Emit || tk.type == .Kw_False || tk.type == .Kw_If || tk.type == .Kw_Import || tk.type == .Kw_Method || tk.type == .Kw_Namespace || tk.type == .Kw_New || tk.type == .Kw_Nil || tk.type == .Kw_Return || tk.type == .Kw_Skip || tk.type == .Kw_True || tk.type == .Lbrace || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String || tk.type == .Lit_Symbol || tk.type == .Lit_Time || tk.type == .Lparen || tk.type == .Op_Amper || tk.type == .Op_Minus || tk.type == .Op_Not || tk.type == .Op_Plus || tk.type == .Op_Tilde {
			parser_end(p)
			parser_begin(p, .Topstmt_Rest, top.node)
			parser_begin(p, .Topstmt, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// topstmt_rest 規則のパース
parse_topstmt_rest :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Topstmt_Rest:
		if tk.type == .Newline || tk.type == .Semicolon {
			parser_end(p)
			parser_begin(p, .Topstmt_List_Opt, top.node)
			parser_begin(p, .Terms, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// topstmt 規則のパース
parse_topstmt :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Topstmt:
		if tk.type == .Kw_Namespace {
			on_parse_event(p, .Topstmt_Kw_Namespace, tk, top)
			tk.consumed = true
			parser_set_state(p, .Topstmt_Await_Ident)
			return .Continue
		} else if tk.type == .Kw_Class {
			on_parse_event(p, .Topstmt_Kw_Class, tk, top)
			tk.consumed = true
			parser_set_state(p, .Topstmt_Await_Ident_2)
			return .Continue
		} else if tk.type == .Kw_Import {
			on_parse_event(p, .Topstmt_Kw_Import, tk, top)
			tk.consumed = true
			parser_set_state(p, .Topstmt_Await_Ident_3)
			return .Continue
		} else if tk.type == .Kw_Method {
			on_parse_event(p, .Topstmt_Kw_Method, tk, top)
			tk.consumed = true
			parser_set_state(p, .Topstmt_Await_Lparen)
			parser_begin(p, .Fname, top.node)
			return .Continue
		} else if tk.type == .Ident || tk.type == .Kw_Def || tk.type == .Kw_Emit || tk.type == .Kw_False || tk.type == .Kw_If || tk.type == .Kw_New || tk.type == .Kw_Nil || tk.type == .Kw_Return || tk.type == .Kw_Skip || tk.type == .Kw_True || tk.type == .Lbrace || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String || tk.type == .Lit_Symbol || tk.type == .Lit_Time || tk.type == .Lparen || tk.type == .Op_Amper || tk.type == .Op_Minus || tk.type == .Op_Not || tk.type == .Op_Plus || tk.type == .Op_Tilde {
			parser_end(p)
			parser_begin(p, .Stmt, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in topstmt: %v", tk.type))
			return .Break
		}
	case .Topstmt_Await_Ident:
		if consumed(tk, .Ident) {
			on_parse_event(p, .Topstmt_Await_Ident, tk, top)
			parser_set_state(p, .Topstmt_Await_Lbrace)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Ident, got %v", tk.type))
		}
	case .Topstmt_Await_Lbrace:
		if consumed(tk, .Lbrace) {
			on_parse_event(p, .Topstmt_Await_Lbrace, tk, top)
			parser_set_state(p, .Topstmt_Await_Rbrace)
			parser_begin(p, .Program, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Lbrace, got %v", tk.type))
		}
	case .Topstmt_Await_Rbrace:
		if consumed(tk, .Rbrace) {
			on_parse_event(p, .Topstmt_Await_Rbrace, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rbrace, got %v", tk.type))
		}
	case .Topstmt_Await_Ident_2:
		if consumed(tk, .Ident) {
			on_parse_event(p, .Topstmt_Await_Ident_2, tk, top)
			parser_set_state(p, .Topstmt_Await_Lbrace_2)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Ident, got %v", tk.type))
		}
	case .Topstmt_Await_Lbrace_2:
		if consumed(tk, .Lbrace) {
			on_parse_event(p, .Topstmt_Await_Lbrace_2, tk, top)
			parser_set_state(p, .Topstmt_Await_Rbrace_2)
			parser_begin(p, .Program, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Lbrace, got %v", tk.type))
		}
	case .Topstmt_Await_Rbrace_2:
		if consumed(tk, .Rbrace) {
			on_parse_event(p, .Topstmt_Await_Rbrace_2, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rbrace, got %v", tk.type))
		}
	case .Topstmt_Await_Ident_3:
		if consumed(tk, .Ident) {
			on_parse_event(p, .Topstmt_Await_Ident_3, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Ident, got %v", tk.type))
		}
	case .Topstmt_Await_Lparen:
		if consumed(tk, .Lparen) {
			on_parse_event(p, .Topstmt_Await_Lparen, tk, top)
			parser_set_state(p, .Topstmt_Await_Rparen)
			parser_begin(p, .Opt_F_Args, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Lparen, got %v", tk.type))
		}
	case .Topstmt_Await_Rparen:
		if consumed(tk, .Rparen) {
			on_parse_event(p, .Topstmt_Await_Rparen, tk, top)
			parser_end(p)
			parser_begin(p, .Method_Body, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rparen, got %v", tk.type))
		}
	}
	return .Break
}

// method_body 規則のパース
parse_method_body :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Method_Body:
		if tk.type == .Lbrace {
			on_parse_event(p, .Method_Body_Lbrace, tk, top)
			tk.consumed = true
			parser_set_state(p, .Method_Body_Await_Rbrace)
			parser_begin(p, .Stmts, top.node)
			return .Continue
		} else if tk.type == .Eq {
			on_parse_event(p, .Method_Body_Eq, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in method_body: %v", tk.type))
			return .Break
		}
	case .Method_Body_Await_Rbrace:
		if consumed(tk, .Rbrace) {
			on_parse_event(p, .Method_Body_Await_Rbrace, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rbrace, got %v", tk.type))
		}
	}
	return .Break
}

// stmts 規則のパース
parse_stmts :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Stmts:
		parser_end(p)
		parser_begin(p, .Stmt_List_Opt, top.node)
		parser_begin(p, .Opt_Terms, top.node)
		return .Continue
	}
	return .Break
}

// stmt_list_opt 規則のパース
parse_stmt_list_opt :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Stmt_List_Opt:
		if tk.type == .Ident || tk.type == .Kw_Def || tk.type == .Kw_Emit || tk.type == .Kw_False || tk.type == .Kw_If || tk.type == .Kw_New || tk.type == .Kw_Nil || tk.type == .Kw_Return || tk.type == .Kw_Skip || tk.type == .Kw_True || tk.type == .Lbrace || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String || tk.type == .Lit_Symbol || tk.type == .Lit_Time || tk.type == .Lparen || tk.type == .Op_Amper || tk.type == .Op_Minus || tk.type == .Op_Not || tk.type == .Op_Plus || tk.type == .Op_Tilde {
			parser_end(p)
			parser_begin(p, .Stmt_Rest, top.node)
			parser_begin(p, .Stmt, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// stmt_rest 規則のパース
parse_stmt_rest :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Stmt_Rest:
		if tk.type == .Newline || tk.type == .Semicolon {
			parser_end(p)
			parser_begin(p, .Stmt_List_Opt, top.node)
			parser_begin(p, .Terms, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// stmt 規則のパース
parse_stmt :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Stmt:
		if tk.type == .Kw_Def {
			on_parse_event(p, .Stmt_Kw_Def, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Def_Body, top.node)
			parser_begin(p, .Fname, top.node)
			return .Continue
		} else if tk.type == .Kw_Skip {
			on_parse_event(p, .Stmt_Kw_Skip, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Kw_Emit {
			on_parse_event(p, .Stmt_Kw_Emit, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Opt_Args, top.node)
			return .Continue
		} else if tk.type == .Kw_Return {
			on_parse_event(p, .Stmt_Kw_Return, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Opt_Args, top.node)
			return .Continue
		} else if tk.type == .Ident || tk.type == .Kw_False || tk.type == .Kw_If || tk.type == .Kw_New || tk.type == .Kw_Nil || tk.type == .Kw_True || tk.type == .Lbrace || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String || tk.type == .Lit_Symbol || tk.type == .Lit_Time || tk.type == .Lparen || tk.type == .Op_Amper || tk.type == .Op_Minus || tk.type == .Op_Not || tk.type == .Op_Plus || tk.type == .Op_Tilde {
			parser_end(p)
			parser_begin(p, .Stmt_Suffix, top.node)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in stmt: %v", tk.type))
			return .Break
		}
	}
	return .Break
}

// stmt_suffix 規則のパース
parse_stmt_suffix :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Stmt_Suffix:
		if tk.type == .Eq {
			on_parse_event(p, .Stmt_Suffix_Eq, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else if tk.type == .Op_Rasgn {
			on_parse_event(p, .Stmt_Suffix_Op_Rasgn, tk, top)
			tk.consumed = true
			parser_set_state(p, .Stmt_Suffix_Await_Ident)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	case .Stmt_Suffix_Await_Ident:
		if consumed(tk, .Ident) {
			on_parse_event(p, .Stmt_Suffix_Await_Ident, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Ident, got %v", tk.type))
		}
	}
	return .Break
}

// def_body 規則のパース
parse_def_body :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Def_Body:
		if tk.type == .Lparen {
			on_parse_event(p, .Def_Body_Lparen, tk, top)
			tk.consumed = true
			parser_set_state(p, .Def_Body_Await_Rparen)
			parser_begin(p, .Opt_F_Args, top.node)
			return .Continue
		} else if tk.type == .Eq {
			on_parse_event(p, .Def_Body_Eq, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in def_body: %v", tk.type))
			return .Break
		}
	case .Def_Body_Await_Rparen:
		if consumed(tk, .Rparen) {
			on_parse_event(p, .Def_Body_Await_Rparen, tk, top)
			parser_end(p)
			parser_begin(p, .Method_Body, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rparen, got %v", tk.type))
		}
	}
	return .Break
}

// expr 規則のパース
parse_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Expr:
		if tk.type == .Kw_If {
			on_parse_event(p, .Expr_Kw_If, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Opt_Else, top.node)
			parser_begin(p, .Opt_Terms, top.node)
			parser_begin(p, .Pipe_Expr, top.node)
			parser_begin(p, .Condition, top.node)
			return .Continue
		} else if tk.type == .Ident || tk.type == .Kw_False || tk.type == .Kw_New || tk.type == .Kw_Nil || tk.type == .Kw_True || tk.type == .Lbrace || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String || tk.type == .Lit_Symbol || tk.type == .Lit_Time || tk.type == .Lparen || tk.type == .Op_Amper || tk.type == .Op_Minus || tk.type == .Op_Not || tk.type == .Op_Plus || tk.type == .Op_Tilde {
			parser_end(p)
			parser_begin(p, .Lambda_Expr, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in expr: %v", tk.type))
			return .Break
		}
	}
	return .Break
}

// lambda_expr 規則のパース
parse_lambda_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Lambda_Expr:
		parser_end(p)
		parser_begin(p, .Pipe_Expr, top.node)
		return .Continue
	}
	return .Break
}

// pipe_expr 規則のパース (演算子ループ: amper_expr (op pipe_expr)*)
parse_pipe_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Pipe_Expr:
		parser_set_state(p, .Pipe_Expr_Op)
		parser_begin(p, .Amper_Expr, top.node)
		return .Continue
	case .Pipe_Expr_Op:
		if tk.type == .Op_Bar {
			on_parse_event(p, .Pipe_Expr_Op, tk, top)
			top.op = tk.lexeme
			tk.consumed = true
			parser_begin(p, .Amper_Expr, top.node)
			return .Continue
		} else {
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// amper_expr 規則のパース (演算子ループ: or_expr (op amper_expr)*)
parse_amper_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Amper_Expr:
		parser_set_state(p, .Amper_Expr_Op)
		parser_begin(p, .Or_Expr, top.node)
		return .Continue
	case .Amper_Expr_Op:
		if tk.type == .Op_Amper {
			on_parse_event(p, .Amper_Expr_Op, tk, top)
			top.op = tk.lexeme
			tk.consumed = true
			parser_begin(p, .Or_Expr, top.node)
			return .Continue
		} else {
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// or_expr 規則のパース (演算子ループ: and_expr (op or_expr)*)
parse_or_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Or_Expr:
		parser_set_state(p, .Or_Expr_Op)
		parser_begin(p, .And_Expr, top.node)
		return .Continue
	case .Or_Expr_Op:
		if tk.type == .Op_Or {
			on_parse_event(p, .Or_Expr_Op, tk, top)
			top.op = tk.lexeme
			tk.consumed = true
			parser_begin(p, .And_Expr, top.node)
			return .Continue
		} else {
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// and_expr 規則のパース (演算子ループ: eq_expr (op and_expr)*)
parse_and_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .And_Expr:
		parser_set_state(p, .And_Expr_Op)
		parser_begin(p, .Eq_Expr, top.node)
		return .Continue
	case .And_Expr_Op:
		if tk.type == .Op_And {
			on_parse_event(p, .And_Expr_Op, tk, top)
			top.op = tk.lexeme
			tk.consumed = true
			parser_begin(p, .Eq_Expr, top.node)
			return .Continue
		} else {
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// eq_expr 規則のパース (演算子ループ: cmp_expr (op eq_expr)*)
parse_eq_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Eq_Expr:
		parser_set_state(p, .Eq_Expr_Op)
		parser_begin(p, .Cmp_Expr, top.node)
		return .Continue
	case .Eq_Expr_Op:
		if tk.type == .Op_Eq || tk.type == .Op_Neq {
			// nonassoc 演算子のチェーン検出
			if top.op != "" && (top.op == "Op_Eq" || top.op == "Op_Neq") {
				parser_error(p, fmt.tprintf("Non-associative operator '%%s' cannot be chained", top.op))
				return .Break
			}
			on_parse_event(p, .Eq_Expr_Op, tk, top)
			top.op = tk.lexeme
			tk.consumed = true
			parser_begin(p, .Cmp_Expr, top.node)
			return .Continue
		} else {
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// cmp_expr 規則のパース (演算子ループ: add_expr (op cmp_expr)*)
parse_cmp_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Cmp_Expr:
		parser_set_state(p, .Cmp_Expr_Op)
		parser_begin(p, .Add_Expr, top.node)
		return .Continue
	case .Cmp_Expr_Op:
		if tk.type == .Op_Lt || tk.type == .Op_Le || tk.type == .Op_Gt || tk.type == .Op_Ge {
			on_parse_event(p, .Cmp_Expr_Op, tk, top)
			top.op = tk.lexeme
			tk.consumed = true
			parser_begin(p, .Add_Expr, top.node)
			return .Continue
		} else {
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// add_expr 規則のパース (演算子ループ: mul_expr (op add_expr)*)
parse_add_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Add_Expr:
		parser_set_state(p, .Add_Expr_Op)
		parser_begin(p, .Mul_Expr, top.node)
		return .Continue
	case .Add_Expr_Op:
		if tk.type == .Op_Plus || tk.type == .Op_Minus {
			on_parse_event(p, .Add_Expr_Op, tk, top)
			top.op = tk.lexeme
			tk.consumed = true
			parser_begin(p, .Mul_Expr, top.node)
			return .Continue
		} else {
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// mul_expr 規則のパース (演算子ループ: unary_expr (op mul_expr)*)
parse_mul_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Mul_Expr:
		parser_set_state(p, .Mul_Expr_Op)
		parser_begin(p, .Unary_Expr, top.node)
		return .Continue
	case .Mul_Expr_Op:
		if tk.type == .Op_Mult || tk.type == .Op_Div || tk.type == .Op_Mod {
			on_parse_event(p, .Mul_Expr_Op, tk, top)
			top.op = tk.lexeme
			tk.consumed = true
			parser_begin(p, .Unary_Expr, top.node)
			return .Continue
		} else {
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// unary_expr 規則のパース
parse_unary_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Unary_Expr:
		if tk.type == .Op_Plus {
			on_parse_event(p, .Unary_Expr_Op_Plus, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Unary_Expr, top.node)
			return .Continue
		} else if tk.type == .Op_Minus {
			on_parse_event(p, .Unary_Expr_Op_Minus, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Unary_Expr, top.node)
			return .Continue
		} else if tk.type == .Op_Not {
			on_parse_event(p, .Unary_Expr_Op_Not, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Unary_Expr, top.node)
			return .Continue
		} else if tk.type == .Op_Tilde {
			on_parse_event(p, .Unary_Expr_Op_Tilde, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Unary_Expr, top.node)
			return .Continue
		} else if tk.type == .Ident || tk.type == .Kw_False || tk.type == .Kw_New || tk.type == .Kw_Nil || tk.type == .Kw_True || tk.type == .Lbrace || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String || tk.type == .Lit_Symbol || tk.type == .Lit_Time || tk.type == .Lparen || tk.type == .Op_Amper {
			parser_end(p)
			parser_begin(p, .Postfix_Expr, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in unary_expr: %v", tk.type))
			return .Break
		}
	}
	return .Break
}

// postfix_expr 規則のパース
parse_postfix_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Postfix_Expr:
		parser_end(p)
		parser_begin(p, .Postfix_Chain, top.node)
		parser_begin(p, .Primary, top.node)
		return .Continue
	}
	return .Break
}

// postfix_chain 規則のパース
parse_postfix_chain :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Postfix_Chain:
		if tk.type == .Dot {
			on_parse_event(p, .Postfix_Chain_Dot, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Postfix_Chain, top.node)
			parser_begin(p, .Postfix_Access, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// postfix_access 規則のパース
parse_postfix_access :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Postfix_Access:
		if tk.type == .Ident || tk.type == .Lit_String {
			parser_end(p)
			parser_begin(p, .Postfix_Call_Args, top.node)
			parser_begin(p, .Fname, top.node)
			return .Continue
		} else if tk.type == .Lparen {
			on_parse_event(p, .Postfix_Access_Lparen, tk, top)
			tk.consumed = true
			parser_set_state(p, .Postfix_Access_Await_Rparen)
			parser_begin(p, .Opt_Args, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in postfix_access: %v", tk.type))
			return .Break
		}
	case .Postfix_Access_Await_Rparen:
		if consumed(tk, .Rparen) {
			on_parse_event(p, .Postfix_Access_Await_Rparen, tk, top)
			parser_end(p)
			parser_begin(p, .Opt_Block, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rparen, got %v", tk.type))
		}
	}
	return .Break
}

// postfix_call_args 規則のパース
parse_postfix_call_args :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Postfix_Call_Args:
		if tk.type == .Lparen {
			on_parse_event(p, .Postfix_Call_Args_Lparen, tk, top)
			tk.consumed = true
			parser_set_state(p, .Postfix_Call_Args_Await_Rparen)
			parser_begin(p, .Opt_Args, top.node)
			return .Continue
		} else if tk.type == .Comma || tk.type == .Dot || tk.type == .Eof || tk.type == .Eq || tk.type == .Ident || tk.type == .Kw_Case || tk.type == .Kw_Def || tk.type == .Kw_Else || tk.type == .Kw_Emit || tk.type == .Kw_False || tk.type == .Kw_If || tk.type == .Kw_New || tk.type == .Kw_Nil || tk.type == .Kw_Return || tk.type == .Kw_Skip || tk.type == .Kw_True || tk.type == .Lbrace || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String || tk.type == .Lit_Symbol || tk.type == .Lit_Time || tk.type == .Lparen || tk.type == .Newline || tk.type == .Op_Amper || tk.type == .Op_And || tk.type == .Op_Bar || tk.type == .Op_Div || tk.type == .Op_Eq || tk.type == .Op_Ge || tk.type == .Op_Gt || tk.type == .Op_Lambda || tk.type == .Op_Le || tk.type == .Op_Lt || tk.type == .Op_Minus || tk.type == .Op_Mod || tk.type == .Op_Mult || tk.type == .Op_Neq || tk.type == .Op_Not || tk.type == .Op_Or || tk.type == .Op_Plus || tk.type == .Op_Rasgn || tk.type == .Op_Tilde || tk.type == .Rbrace || tk.type == .Rbracket || tk.type == .Rparen || tk.type == .Semicolon {
			parser_end(p)
			parser_begin(p, .Opt_Block, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in postfix_call_args: %v", tk.type))
			return .Break
		}
	case .Postfix_Call_Args_Await_Rparen:
		if consumed(tk, .Rparen) {
			on_parse_event(p, .Postfix_Call_Args_Await_Rparen, tk, top)
			parser_end(p)
			parser_begin(p, .Opt_Block, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rparen, got %v", tk.type))
		}
	}
	return .Break
}

// primary 規則のパース
parse_primary :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Primary:
		if tk.type == .Lit_Number {
			on_parse_event(p, .Primary_Lit_Number, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Lit_String {
			on_parse_event(p, .Primary_Lit_String, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Lit_Symbol {
			on_parse_event(p, .Primary_Lit_Symbol, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Lit_Time {
			on_parse_event(p, .Primary_Lit_Time, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Ident {
			parser_end(p)
			parser_begin(p, .Ident_Or_Call, top.node)
			return .Continue
		} else if tk.type == .Lparen {
			parser_end(p)
			parser_begin(p, .Paren_Expr, top.node)
			return .Continue
		} else if tk.type == .Lbracket {
			parser_end(p)
			parser_begin(p, .Bracket_Expr, top.node)
			return .Continue
		} else if tk.type == .Lbrace {
			parser_end(p)
			parser_begin(p, .Block, top.node)
			return .Continue
		} else if tk.type == .Kw_Nil {
			on_parse_event(p, .Primary_Kw_Nil, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Kw_True {
			on_parse_event(p, .Primary_Kw_True, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Kw_False {
			on_parse_event(p, .Primary_Kw_False, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Kw_New {
			on_parse_event(p, .Primary_Kw_New, tk, top)
			tk.consumed = true
			parser_set_state(p, .Primary_Await_Ident)
			return .Continue
		} else if tk.type == .Op_Amper {
			on_parse_event(p, .Primary_Op_Amper, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Fname, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in primary: %v", tk.type))
			return .Break
		}
	case .Primary_Await_Ident:
		if consumed(tk, .Ident) {
			on_parse_event(p, .Primary_Await_Ident, tk, top)
			parser_set_state(p, .Primary_Await_Lbracket)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Ident, got %v", tk.type))
		}
	case .Primary_Await_Lbracket:
		if consumed(tk, .Lbracket) {
			on_parse_event(p, .Primary_Await_Lbracket, tk, top)
			parser_set_state(p, .Primary_Await_Rbracket)
			parser_begin(p, .Opt_Args, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Lbracket, got %v", tk.type))
		}
	case .Primary_Await_Rbracket:
		if consumed(tk, .Rbracket) {
			on_parse_event(p, .Primary_Await_Rbracket, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rbracket, got %v", tk.type))
		}
	}
	return .Break
}

// ident_or_call 規則のパース
parse_ident_or_call :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Ident_Or_Call:
		on_parse_event(p, .Ident_Or_Call_Ident, tk, top)
		tk.consumed = true
		parser_end(p)
		parser_begin(p, .Ident_Suffix, top.node)
		return .Continue
	}
	return .Break
}

// ident_suffix 規則のパース
parse_ident_suffix :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Ident_Suffix:
		if tk.type == .Lbrace {
			on_parse_event(p, .Ident_Suffix_Lbrace, tk, top)
			tk.consumed = true
			parser_set_state(p, .Ident_Suffix_Await_Rbrace)
			parser_begin(p, .Block_Content, top.node)
			return .Continue
		} else if tk.type == .Lparen {
			on_parse_event(p, .Ident_Suffix_Lparen, tk, top)
			tk.consumed = true
			parser_set_state(p, .Ident_Suffix_Await_Rparen)
			parser_begin(p, .Opt_Args, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	case .Ident_Suffix_Await_Rbrace:
		if consumed(tk, .Rbrace) {
			on_parse_event(p, .Ident_Suffix_Await_Rbrace, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rbrace, got %v", tk.type))
		}
	case .Ident_Suffix_Await_Rparen:
		if consumed(tk, .Rparen) {
			on_parse_event(p, .Ident_Suffix_Await_Rparen, tk, top)
			parser_end(p)
			parser_begin(p, .Opt_Block, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rparen, got %v", tk.type))
		}
	}
	return .Break
}

// paren_expr 規則のパース
parse_paren_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Paren_Expr:
		on_parse_event(p, .Paren_Expr_Lparen, tk, top)
		tk.consumed = true
		parser_end(p)
		parser_begin(p, .Paren_Content, top.node)
		return .Continue
	}
	return .Break
}

// paren_content 規則のパース
parse_paren_content :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Paren_Content:
		if tk.type == .Ident || tk.type == .Kw_False || tk.type == .Kw_If || tk.type == .Kw_New || tk.type == .Kw_Nil || tk.type == .Kw_True || tk.type == .Lbrace || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String || tk.type == .Lit_Symbol || tk.type == .Lit_Time || tk.type == .Lparen || tk.type == .Op_Amper || tk.type == .Op_Minus || tk.type == .Op_Not || tk.type == .Op_Plus || tk.type == .Op_Tilde {
			parser_set_state(p, .Paren_Content_Await_Rparen)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else if tk.type == .Rparen {
			on_parse_event(p, .Paren_Content_Rparen, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Paren_Suffix, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in paren_content: %v", tk.type))
			return .Break
		}
	case .Paren_Content_Await_Rparen:
		if consumed(tk, .Rparen) {
			on_parse_event(p, .Paren_Content_Await_Rparen, tk, top)
			parser_end(p)
			parser_begin(p, .Paren_Suffix, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rparen, got %v", tk.type))
		}
	}
	return .Break
}

// paren_suffix 規則のパース
parse_paren_suffix :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Paren_Suffix:
		if tk.type == .Op_Lambda2 {
			on_parse_event(p, .Paren_Suffix_Op_Lambda2, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else if tk.type == .Op_Lambda3 {
			on_parse_event(p, .Paren_Suffix_Op_Lambda3, tk, top)
			tk.consumed = true
			parser_set_state(p, .Paren_Suffix_Await_Rbrace)
			parser_begin(p, .Stmts, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	case .Paren_Suffix_Await_Rbrace:
		if consumed(tk, .Rbrace) {
			on_parse_event(p, .Paren_Suffix_Await_Rbrace, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rbrace, got %v", tk.type))
		}
	}
	return .Break
}

// bracket_expr 規則のパース
parse_bracket_expr :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Bracket_Expr:
		on_parse_event(p, .Bracket_Expr_Lbracket, tk, top)
		tk.consumed = true
		parser_end(p)
		parser_begin(p, .Bracket_Content, top.node)
		return .Continue
	}
	return .Break
}

// bracket_content 規則のパース
parse_bracket_content :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Bracket_Content:
		if tk.type == .Ident || tk.type == .Kw_False || tk.type == .Kw_If || tk.type == .Kw_New || tk.type == .Kw_Nil || tk.type == .Kw_True || tk.type == .Label || tk.type == .Lbrace || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String || tk.type == .Lit_Symbol || tk.type == .Lit_Time || tk.type == .Lparen || tk.type == .Op_Amper || tk.type == .Op_Minus || tk.type == .Op_Mult || tk.type == .Op_Not || tk.type == .Op_Plus || tk.type == .Op_Tilde {
			parser_set_state(p, .Bracket_Content_Await_Rbracket)
			parser_begin(p, .Arg, top.node)
			return .Continue
		} else if tk.type == .Rbracket {
			on_parse_event(p, .Bracket_Content_Rbracket, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in bracket_content: %v", tk.type))
			return .Break
		}
	case .Bracket_Content_Await_Rbracket:
		if consumed(tk, .Rbracket) {
			on_parse_event(p, .Bracket_Content_Await_Rbracket, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rbracket, got %v", tk.type))
		}
	}
	return .Break
}

// block 規則のパース
parse_block :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Block:
		on_parse_event(p, .Block_Lbrace, tk, top)
		tk.consumed = true
		parser_set_state(p, .Block_Await_Rbrace)
		parser_begin(p, .Block_Content, top.node)
		return .Continue
	case .Block_Await_Rbrace:
		if consumed(tk, .Rbrace) {
			on_parse_event(p, .Block_Await_Rbrace, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rbrace, got %v", tk.type))
		}
	}
	return .Break
}

// block_content 規則のパース
parse_block_content :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Block_Content:
		if tk.type == .Op_Lambda {
			on_parse_event(p, .Block_Content_Op_Lambda, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Stmts, top.node)
			return .Continue
		} else if tk.type == .Kw_Case {
			on_parse_event(p, .Block_Content_Kw_Case, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Case_Body_Rest, top.node)
			return .Continue
		} else if tk.type == .Ident {
			on_parse_event(p, .Block_Content_Ident, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Block_After_Ident, top.node)
			return .Continue
		} else if tk.type == .Ident || tk.type == .Kw_Def || tk.type == .Kw_Emit || tk.type == .Kw_False || tk.type == .Kw_If || tk.type == .Kw_New || tk.type == .Kw_Nil || tk.type == .Kw_Return || tk.type == .Kw_Skip || tk.type == .Kw_True || tk.type == .Lbrace || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String || tk.type == .Lit_Symbol || tk.type == .Lit_Time || tk.type == .Lparen || tk.type == .Newline || tk.type == .Op_Amper || tk.type == .Op_Minus || tk.type == .Op_Not || tk.type == .Op_Plus || tk.type == .Op_Tilde || tk.type == .Rbrace || tk.type == .Semicolon {
			parser_end(p)
			parser_begin(p, .Stmts, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in block_content: %v", tk.type))
			return .Break
		}
	}
	return .Break
}

// block_after_ident 規則のパース
parse_block_after_ident :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Block_After_Ident:
		if tk.type == .Comma {
			on_parse_event(p, .Block_After_Ident_Comma, tk, top)
			tk.consumed = true
			parser_set_state(p, .Block_After_Ident_Await_Ident)
			return .Continue
		} else if tk.type == .Op_Lambda {
			on_parse_event(p, .Block_After_Ident_Op_Lambda, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Stmts, top.node)
			return .Continue
		} else if tk.type == .Eq || tk.type == .Ident || tk.type == .Kw_Def || tk.type == .Kw_Emit || tk.type == .Kw_False || tk.type == .Kw_If || tk.type == .Kw_New || tk.type == .Kw_Nil || tk.type == .Kw_Return || tk.type == .Kw_Skip || tk.type == .Kw_True || tk.type == .Lbrace || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String || tk.type == .Lit_Symbol || tk.type == .Lit_Time || tk.type == .Lparen || tk.type == .Newline || tk.type == .Op_Amper || tk.type == .Op_Minus || tk.type == .Op_Not || tk.type == .Op_Plus || tk.type == .Op_Rasgn || tk.type == .Op_Tilde || tk.type == .Rbrace || tk.type == .Semicolon {
			parser_end(p)
			parser_begin(p, .Stmt_List_Opt, top.node)
			parser_begin(p, .Opt_Terms, top.node)
			parser_begin(p, .Stmt_Suffix, top.node)
			parser_begin(p, .Ident_Suffix, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in block_after_ident: %v", tk.type))
			return .Break
		}
	case .Block_After_Ident_Await_Ident:
		if consumed(tk, .Ident) {
			on_parse_event(p, .Block_After_Ident_Await_Ident, tk, top)
			parser_set_state(p, .Block_After_Ident_Await_Op_Lambda)
			parser_begin(p, .F_Args_Rest, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Ident, got %v", tk.type))
		}
	case .Block_After_Ident_Await_Op_Lambda:
		if consumed(tk, .Op_Lambda) {
			on_parse_event(p, .Block_After_Ident_Await_Op_Lambda, tk, top)
			parser_end(p)
			parser_begin(p, .Stmts, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Op_Lambda, got %v", tk.type))
		}
	}
	return .Break
}

// case_body_rest 規則のパース
parse_case_body_rest :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Case_Body_Rest:
		parser_end(p)
		parser_begin(p, .Case_Body_Cont, top.node)
		parser_begin(p, .Stmts, top.node)
		parser_begin(p, .Cparam, top.node)
		return .Continue
	}
	return .Break
}

// case_body_cont 規則のパース
parse_case_body_cont :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Case_Body_Cont:
		if tk.type == .Kw_Case {
			on_parse_event(p, .Case_Body_Cont_Kw_Case, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Case_Body_Cont, top.node)
			parser_begin(p, .Stmts, top.node)
			parser_begin(p, .Cparam, top.node)
			return .Continue
		} else if tk.type == .Kw_Else {
			on_parse_event(p, .Case_Body_Cont_Kw_Else, tk, top)
			tk.consumed = true
			parser_set_state(p, .Case_Body_Cont_Await_Op_Lambda)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	case .Case_Body_Cont_Await_Op_Lambda:
		if consumed(tk, .Op_Lambda) {
			on_parse_event(p, .Case_Body_Cont_Await_Op_Lambda, tk, top)
			parser_end(p)
			parser_begin(p, .Stmts, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Op_Lambda, got %v", tk.type))
		}
	}
	return .Break
}

// condition 規則のパース
parse_condition :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Condition:
		on_parse_event(p, .Condition_Lparen, tk, top)
		tk.consumed = true
		parser_set_state(p, .Condition_Await_Rparen)
		parser_begin(p, .Expr, top.node)
		return .Continue
	case .Condition_Await_Rparen:
		if consumed(tk, .Rparen) {
			on_parse_event(p, .Condition_Await_Rparen, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rparen, got %v", tk.type))
		}
	}
	return .Break
}

// opt_else 規則のパース
parse_opt_else :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Opt_Else:
		if tk.type == .Kw_Else {
			on_parse_event(p, .Opt_Else_Kw_Else, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// opt_args 規則のパース
parse_opt_args :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Opt_Args:
		if tk.type == .Ident || tk.type == .Kw_False || tk.type == .Kw_If || tk.type == .Kw_New || tk.type == .Kw_Nil || tk.type == .Kw_True || tk.type == .Label || tk.type == .Lbrace || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String || tk.type == .Lit_Symbol || tk.type == .Lit_Time || tk.type == .Lparen || tk.type == .Op_Amper || tk.type == .Op_Minus || tk.type == .Op_Mult || tk.type == .Op_Not || tk.type == .Op_Plus || tk.type == .Op_Tilde {
			parser_end(p)
			parser_begin(p, .Arg_Rest, top.node)
			parser_begin(p, .Arg, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// arg 規則のパース
parse_arg :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Arg:
		if tk.type == .Label {
			on_parse_event(p, .Arg_Label, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else if tk.type == .Op_Mult {
			on_parse_event(p, .Arg_Op_Mult, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else if tk.type == .Ident || tk.type == .Kw_False || tk.type == .Kw_If || tk.type == .Kw_New || tk.type == .Kw_Nil || tk.type == .Kw_True || tk.type == .Lbrace || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String || tk.type == .Lit_Symbol || tk.type == .Lit_Time || tk.type == .Lparen || tk.type == .Op_Amper || tk.type == .Op_Minus || tk.type == .Op_Not || tk.type == .Op_Plus || tk.type == .Op_Tilde {
			parser_end(p)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in arg: %v", tk.type))
			return .Break
		}
	}
	return .Break
}

// arg_rest 規則のパース
parse_arg_rest :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Arg_Rest:
		if tk.type == .Comma {
			on_parse_event(p, .Arg_Rest_Comma, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Arg_Rest, top.node)
			parser_begin(p, .Arg, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// opt_f_args 規則のパース
parse_opt_f_args :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Opt_F_Args:
		if tk.type == .Ident {
			on_parse_event(p, .Opt_F_Args_Ident, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .F_Args_Rest, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// f_args_rest 規則のパース
parse_f_args_rest :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .F_Args_Rest:
		if tk.type == .Comma {
			on_parse_event(p, .F_Args_Rest_Comma, tk, top)
			tk.consumed = true
			parser_set_state(p, .F_Args_Rest_Await_Ident)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	case .F_Args_Rest_Await_Ident:
		if consumed(tk, .Ident) {
			on_parse_event(p, .F_Args_Rest_Await_Ident, tk, top)
			parser_end(p)
			parser_begin(p, .F_Args_Rest, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Ident, got %v", tk.type))
		}
	}
	return .Break
}

// fname 規則のパース
parse_fname :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Fname:
		if tk.type == .Ident {
			on_parse_event(p, .Fname_Ident, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Lit_String {
			on_parse_event(p, .Fname_Lit_String, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in fname: %v", tk.type))
			return .Break
		}
	}
	return .Break
}

// cparam 規則のパース
parse_cparam :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Cparam:
		if tk.type == .Op_Lambda {
			on_parse_event(p, .Cparam_Op_Lambda, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Kw_If {
			on_parse_event(p, .Cparam_Kw_If, tk, top)
			tk.consumed = true
			parser_set_state(p, .Cparam_Await_Op_Lambda)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else if tk.type == .Ident || tk.type == .Kw_False || tk.type == .Kw_Nil || tk.type == .Kw_True || tk.type == .Label || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String {
			parser_set_state(p, .Cparam_Await_Op_Lambda_2)
			parser_begin(p, .Pattern, top.node)
			return .Continue
		} else if tk.type == .Ident || tk.type == .Kw_False || tk.type == .Kw_Nil || tk.type == .Kw_True || tk.type == .Label || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String {
			parser_set_state(p, .Cparam_Await_Kw_If)
			parser_begin(p, .Pattern, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in cparam: %v", tk.type))
			return .Break
		}
	case .Cparam_Await_Op_Lambda:
		if consumed(tk, .Op_Lambda) {
			on_parse_event(p, .Cparam_Await_Op_Lambda, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Op_Lambda, got %v", tk.type))
		}
	case .Cparam_Await_Op_Lambda_2:
		if consumed(tk, .Op_Lambda) {
			on_parse_event(p, .Cparam_Await_Op_Lambda_2, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Op_Lambda, got %v", tk.type))
		}
	case .Cparam_Await_Kw_If:
		if consumed(tk, .Kw_If) {
			on_parse_event(p, .Cparam_Await_Kw_If, tk, top)
			parser_set_state(p, .Cparam_Await_Op_Lambda_3)
			parser_begin(p, .Expr, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Kw_If, got %v", tk.type))
		}
	case .Cparam_Await_Op_Lambda_3:
		if consumed(tk, .Op_Lambda) {
			on_parse_event(p, .Cparam_Await_Op_Lambda_3, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Op_Lambda, got %v", tk.type))
		}
	}
	return .Break
}

// pattern 規則のパース
parse_pattern :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Pattern:
		parser_end(p)
		parser_begin(p, .Pattern_Splat_Opt, top.node)
		parser_begin(p, .Pary_Or_Pstruct, top.node)
		return .Continue
	}
	return .Break
}

// pary_or_pstruct 規則のパース
parse_pary_or_pstruct :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Pary_Or_Pstruct:
		if tk.type == .Ident || tk.type == .Kw_False || tk.type == .Kw_Nil || tk.type == .Kw_True || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String {
			parser_end(p)
			parser_begin(p, .Pary_Rest, top.node)
			parser_begin(p, .Pterm, top.node)
			return .Continue
		} else if tk.type == .Label {
			on_parse_event(p, .Pary_Or_Pstruct_Label, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Pstruct_Rest, top.node)
			parser_begin(p, .Pterm, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in pary_or_pstruct: %v", tk.type))
			return .Break
		}
	}
	return .Break
}

// pary_rest 規則のパース
parse_pary_rest :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Pary_Rest:
		if tk.type == .Comma {
			on_parse_event(p, .Pary_Rest_Comma, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Pary_Rest, top.node)
			parser_begin(p, .Pterm, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// pstruct_rest 規則のパース
parse_pstruct_rest :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Pstruct_Rest:
		if tk.type == .Comma {
			on_parse_event(p, .Pstruct_Rest_Comma, tk, top)
			tk.consumed = true
			parser_set_state(p, .Pstruct_Rest_Await_Label)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	case .Pstruct_Rest_Await_Label:
		if consumed(tk, .Label) {
			on_parse_event(p, .Pstruct_Rest_Await_Label, tk, top)
			parser_end(p)
			parser_begin(p, .Pstruct_Rest, top.node)
			parser_begin(p, .Pterm, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Label, got %v", tk.type))
		}
	}
	return .Break
}

// pattern_splat_opt 規則のパース
parse_pattern_splat_opt :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Pattern_Splat_Opt:
		if tk.type == .Comma {
			on_parse_event(p, .Pattern_Splat_Opt_Comma, tk, top)
			tk.consumed = true
			parser_set_state(p, .Pattern_Splat_Opt_Await_Op_Mult)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	case .Pattern_Splat_Opt_Await_Op_Mult:
		if consumed(tk, .Op_Mult) {
			on_parse_event(p, .Pattern_Splat_Opt_Await_Op_Mult, tk, top)
			parser_end(p)
			parser_begin(p, .Splat_Tail, top.node)
			parser_begin(p, .Pterm, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Op_Mult, got %v", tk.type))
		}
	}
	return .Break
}

// splat_tail 規則のパース
parse_splat_tail :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Splat_Tail:
		if tk.type == .Comma {
			on_parse_event(p, .Splat_Tail_Comma, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Pary_Or_Pstruct, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// pterm 規則のパース
parse_pterm :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Pterm:
		if tk.type == .Ident {
			on_parse_event(p, .Pterm_Ident, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Pterm_Suffix, top.node)
			return .Continue
		} else if tk.type == .Lit_Number {
			on_parse_event(p, .Pterm_Lit_Number, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Lit_String {
			on_parse_event(p, .Pterm_Lit_String, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Kw_Nil {
			on_parse_event(p, .Pterm_Kw_Nil, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Kw_True {
			on_parse_event(p, .Pterm_Kw_True, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Kw_False {
			on_parse_event(p, .Pterm_Kw_False, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Lbracket {
			on_parse_event(p, .Pterm_Lbracket, tk, top)
			tk.consumed = true
			parser_end(p)
			parser_begin(p, .Pterm_Bracket_Content, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in pterm: %v", tk.type))
			return .Break
		}
	}
	return .Break
}

// pterm_suffix 規則のパース
parse_pterm_suffix :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Pterm_Suffix:
		if tk.type == .At {
			on_parse_event(p, .Pterm_Suffix_At, tk, top)
			tk.consumed = true
			parser_set_state(p, .Pterm_Suffix_Await_Ident)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	case .Pterm_Suffix_Await_Ident:
		if consumed(tk, .Ident) {
			on_parse_event(p, .Pterm_Suffix_Await_Ident, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Ident, got %v", tk.type))
		}
	}
	return .Break
}

// pterm_bracket_content 規則のパース
parse_pterm_bracket_content :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Pterm_Bracket_Content:
		if tk.type == .Rbracket {
			on_parse_event(p, .Pterm_Bracket_Content_Rbracket, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .At {
			on_parse_event(p, .Pterm_Bracket_Content_At, tk, top)
			tk.consumed = true
			parser_set_state(p, .Pterm_Bracket_Content_Await_Ident)
			return .Continue
		} else if tk.type == .Ident || tk.type == .Kw_False || tk.type == .Kw_Nil || tk.type == .Kw_True || tk.type == .Label || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String {
			parser_set_state(p, .Pterm_Bracket_Content_Await_Rbracket)
			parser_begin(p, .Pattern, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in pterm_bracket_content: %v", tk.type))
			return .Break
		}
	case .Pterm_Bracket_Content_Await_Ident:
		if consumed(tk, .Ident) {
			on_parse_event(p, .Pterm_Bracket_Content_Await_Ident, tk, top)
			parser_end(p)
			parser_begin(p, .Pterm_Bracket_At, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Ident, got %v", tk.type))
		}
	case .Pterm_Bracket_Content_Await_Rbracket:
		if consumed(tk, .Rbracket) {
			on_parse_event(p, .Pterm_Bracket_Content_Await_Rbracket, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rbracket, got %v", tk.type))
		}
	}
	return .Break
}

// pterm_bracket_at 規則のパース
parse_pterm_bracket_at :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Pterm_Bracket_At:
		if tk.type == .Rbracket {
			on_parse_event(p, .Pterm_Bracket_At_Rbracket, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Ident || tk.type == .Kw_False || tk.type == .Kw_Nil || tk.type == .Kw_True || tk.type == .Label || tk.type == .Lbracket || tk.type == .Lit_Number || tk.type == .Lit_String {
			parser_set_state(p, .Pterm_Bracket_At_Await_Rbracket)
			parser_begin(p, .Pattern, top.node)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in pterm_bracket_at: %v", tk.type))
			return .Break
		}
	case .Pterm_Bracket_At_Await_Rbracket:
		if consumed(tk, .Rbracket) {
			on_parse_event(p, .Pterm_Bracket_At_Await_Rbracket, tk, top)
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Expected Rbracket, got %v", tk.type))
		}
	}
	return .Break
}

// opt_terms 規則のパース
parse_opt_terms :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Opt_Terms:
		if tk.type == .Newline || tk.type == .Semicolon {
			parser_end(p)
			parser_begin(p, .Terms, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// terms 規則のパース
parse_terms :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Terms:
		parser_end(p)
		parser_begin(p, .Terms_Rest, top.node)
		parser_begin(p, .Term, top.node)
		return .Continue
	}
	return .Break
}

// terms_rest 規則のパース
parse_terms_rest :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Terms_Rest:
		if tk.type == .Newline || tk.type == .Semicolon {
			parser_end(p)
			parser_begin(p, .Terms_Rest, top.node)
			parser_begin(p, .Term, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

// term 規則のパース
parse_term :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Term:
		if tk.type == .Semicolon {
			on_parse_event(p, .Term_Semicolon, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else if tk.type == .Newline {
			on_parse_event(p, .Term_Newline, tk, top)
			tk.consumed = true
			parser_end(p)
			return .Continue
		} else {
			parser_error(p, fmt.tprintf("Unexpected token in term: %v", tk.type))
			return .Break
		}
	}
	return .Break
}

// opt_block 規則のパース
parse_opt_block :: proc(p: ^Parser, tk: ^Token) -> Parse_Loop_Action {
	top := parser_get_state(p)
	if top == nil { return .Break }

	#partial switch top.state {
	case .Opt_Block:
		if tk.type == .Lbrace {
			parser_end(p)
			parser_begin(p, .Block, top.node)
			return .Continue
		} else {
			// ε production
			parser_end(p)
			return .Continue
		}
	}
	return .Break
}

